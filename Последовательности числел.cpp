/*******************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  №1  З А   3   С Е М Е С Т Р   С  +  +*
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Функции и последовательности чисел                          *
 * File Name     : Функции и последовательности чисел. CPP                     *
 * Programmer(s) : Викулов Д.Г.                                                *
 * Modifyed By   :                                                             *
 * Created       : 15/09/22                                                    *
 * Last Revision : 27/09/22                                                    *
 * Comment(s)    : Формирование монотонных (упорядоченных и упорядоченных в    *
 *                 обратном порядке), частично упорядоченных и случайных       *
 *                 последовательностей данных. Использование указателей на     *
 *                 функции, а также массива указателей                         *
 *******************************************************************************/

#include <iostream>     // стандартные потоки ввода/вывода
#include <fstream>      // файловые потоки ввода/вывода
#include <iomanip>      // библиотека с модификатором setw
#include <chrono>       // подключение библиотеки для вычисления времени работы алгоритмов 

using namespace std;    // используем пространство имён std


/*******************************************************************/
/*                    Н А Б О Р    Ф А Й Л О В                     */
/*******************************************************************/
// ДЛЯ ЦЕЛЫХ ЧИСЕЛ
//const char* FNAME_1 = "Nope_int.txt";
const char* FNAME_1 = "Integer.txt";               // путь к файлу через константный указатель

// ДЛЯ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ
//const char* FNAME_2 = "Nope_doub.txt";
const char* FNAME_2 = "Double.txt";

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   К О Н С Т А Н Т Ы              */
/*******************************************************************/
const int interval = 20;                           // интервал роста функции

/*******************************************************************/
/*              П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/*******************************************************************/

// печать начальных условий для выбора функции
void pechatusloviy();                            // функция не принимает ничего, т. к. просто идёт печать

// ДЛЯ ЦЕЛЫХ ЧИСЕЛ
// формирование монотонной упорядоченной по возрастанию последовательности
int linevozrastanie(int* pznachenue              // указатель на первый элемент динамического вектора
	              , int number                   // количество элементов в векторе
	              , const int rand_max);         // максимальное случайное число

// формирование монотонной упорядоченной по убыванию последовательности
int lineubuvanie(int* pznachenue                 // указатель на первый элемент динамического вектора
	           , int number                      // количество элементов в векторе
	           , const int rand_max);            // максимальное случайное число

// формирование случайной последовательности чисел
int slucaynaya(  int* pznachenue                 // указатель на первый элемент динамического вектора
	           , int number                      // количество элементов в векторе
	           , const int rand_max);            // максимальное случайное число

// формирование полообразной последовательности
int piloobraznaya(int* pznachenue                // указатель на первый элемент динамического вектора
	            , int number                     // количество элементов в векторе
	            , const int rand_max);           // максимальное случайное число

// формирование ступенчатой последовательности 
int stupenchataya(int* pznachenue                // указатель на первый элемент динамического вектора 
	            , int number                     // количество элементов в векторе
	            , const int rand_max);           // максимальное случайное число

// формирование квази-упорядоченной последовательности
int kvazi(int* pznachenue                        // указатель на первый элемент динамического вектора
	    , int number                             // количество элементов в векторе
	    , const int rand_max);                   // максимальное случайное число

// формирование синусоидальной последовательности
int sinus(int* pznachenue                        // указатель на первый элемент динамического вектора
	    , int number                             // количество элементов в векторе
	    , const int rand_max);                   // максимальное случайное число

// создание динамического массива - вектора
void sozdanie(int** pznachenue                   // адрес указателя на динамический вектор, для изменения значения указателя 
	        , int& number);                      // количество элементов в векторе для изменения

// удаление динамического массива - вектора
void udalenie(int* pznachenue);                  // указатель на первый элемент динамического вектора

// промежуточная функция выбора функции из массива
int(*MENU())(int*, int, const int);              // в первых скобках имя функции со списком параметров. Далее спецификация параметров функции

// печать выбранной функции на экран и в файл
void pechat_int_mass(int* pznachenue             // указатель на первый элемент динамического вектора
                   , int  number                 // количество элементов в векторе
	               , const int rand_max);        // максимальное случайное число


// ДЛЯ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ
// формирование монотонной упорядоченной по возрастанию последовательности
double linevozrastanie(double* pznacheniedoub    // указатель на первый элемент динамического вектора
	                 , int number                // количество элементов в векторе
	                 , const int rand_max);      // максимальное случайное число

// формирование монотонной упорядоченной по убыванию последовательности
double lineubuvanie(double* pznacheniedoub      // указатель на первый элемент динамического вектора
	              , int number                  // количество элементов в векторе
	              , const int rand_max);        // максимальное случайное число

// формирование случайной последовательности чисел
double slucaynaya(double* pznacheniedoub        // указатель на первый элемент динамического вектора
	            , int number                    // количество элементов в векторе
	            , const int rand_max);          // максимальное случайное число

// формирование полообразной последовательности
double piloobraznaya(double* pznacheniedoub     // указатель на первый элемент динамического вектора
	               , int number                 // количество элементов в векторе
	               , const int rand_max);       // максимальное случайное число

// формирование ступенчатой последовательности 
double stupenchataya(double* pznacheniedoub     // указатель на первый элемент динамического вектора
	               , int number                 // количество элементов в векторе
	               , const int rand_max);       // максимальное случайное число

// формирование квази-упорядоченной последовательности
double kvazi(double* pznacheniedoub             // указатель на первый элемент динамического вектора
	       , int number                         // количество элементов в векторе
	       , const int rand_max);               // максимальное случайное число

// формирование синусоидальной последовательности
double sinus(double* pznacheniedoub             // указатель на первый элемент динамического вектора
	, int number                                // количество элементов в векторе
	, const int rand_max);                      // максимальное случайное число

// создание динамического массива - вектора
void sozdanie(double** pznacheniedoub           // адрес указателя на динамический вектор, для изменения значения указателя 
	        , int& number);                     // количество элементов в векторе по ссылке для ввода пользователем

// удаление динамического массива - вектора
void udalenie(double* pznacheniedoub);          // указатель на первый элемент динамического вектора

// промежуточная функция выбора фукции из массива
double (*MENU2())(double*, int, const int);     // в первых скобках имя функции со списком параметров. Далее спецификация параметров функции

// печать выбранной функции на экран и в файл
void pechat_doub_mass(double pznacheniedoub[]   // указатель на первый элемент динамического вектора
	                , int number                // количество элементов в векторе
	                , const int rand_max);      // максимальное случайное число

/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/

int main()
{
	system("color F0");                         // делаем консоль светлой
	setlocale(LC_ALL, "Rus");                   // подключаем русский язык
	system("cls");                              // чистим консоль перед выводом

	int number = 0;                             // количество элементов последовательности
	const int rand_max = 15;                    // ограничение на рандомные числа
	int* pznachenue = NULL;                     // указатель на динамический массив целых чисел
	double* pznacheniedoub = NULL;              // указатель на динамический массив чисел с плавающей точкой
	pechat_int_mass(pznachenue, number, rand_max);       // вызов функции печати массива целых чисел
	system("cls");                                       // чистим консоль перед выводом чисел с плавающей точкой
	pechat_doub_mass(pznacheniedoub, number, rand_max);  // вызов функции печати массива чисел с плавающей точкой
	return 0;                                            // возвращаем обещанное значение
} //main()

 /***************************************************/
 /*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
 /***************************************************/

/*-------------------------------------------------*/
/* печать условий для выбора функции */
/*-----------------------------------*/
void pechatusloviy()
{
	// Выводим условия в таблице
	setlocale(0, "C");                         // отключаем русский язык
	cout<< char(218) << setw(30) << setfill((char)196)<< (char)191 << endl << (char)179;               // выводим верхнюю строку шапки
	setlocale(LC_ALL, "Rus");                  // подключаем русский язык
	cout << "     Выберите функцию:       ";
	setlocale(0, "C");                         // отключаем русский язык
	cout<< (char)179<< endl <<(char)195 << setw(30) << (char)180 << setfill(' ') << endl<< (char)179; // выводим нижнюю строку шапки
	cout << "      1. sluchainaya         ";                                                          // выводим условия выбора и нижнюю с боковыми строчками таблицы
	cout << (char)179 << endl << (char)195 << setw(30)<< setfill((char)196) << (char)180 << endl << (char)179;
	cout << "      2. ubivaushaya         " ;
	cout << (char)179 <<endl<< (char)195 << setw(30) << (char)180 << setfill(' ') << endl << (char)179;
	cout << "      3. vozrastaushaya      " ;
	cout << (char)179 << endl << (char)195 << setw(30) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "      4. pila                ";
	cout << (char)179 << endl << (char)195 << setw(30) << (char)180 << setfill(' ') << endl << (char)179;
	cout << "      5. stupenka            ";
	cout << (char)179 << endl << (char)195 << setw(30) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "      6. kvazi               ";
	cout << (char)179 << endl << (char)195 << setw(30) << (char)180 << setfill(' ') << endl << (char)179;
	cout << "      7. sinus               ";
	cout << (char)179 << endl << (char)195 << setw(30) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "      8: Exit.               ";
	cout << (char)179 << endl << (char)195 << setw(30) << (char)180 << setfill(' ') << endl;
	setlocale(LC_ALL, "Rus");                  // подключаем русский язык
	return;                                    // возвращаем обещанное значение
}// pechatusloviy()


/*-------------------------------------------------*/
/* монотонно-возрастающая последовательность */
/*-------------------------------------------*/
int linevozrastanie(int* pznachenue            // указатель на первый  элемент динамического вектора
	              , int number                 // количество элементов в векторе
	              , const int rand_max)        // максимальное случайное число
{
	*(pznachenue + 0) = rand() % rand_max;     // значение последовательности при одном элементе

	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++) 
	{
		*(pznachenue + n) = *(pznachenue + (n - 1)) + rand() % rand_max + 1; // следующий элемент больше предыдущего на случайное число
	}// for
	return 0;                                  // возвращаем обещанное значение
}// linevozrastanie()


/*-------------------------------------------------*/
/* монотонно-убывающая последовательность    */
/*-------------------------------------------*/
int lineubuvanie(int * pznachenue              // указатель на первый  элемент динамического вектора
	           , int number                    // количество элементов в векторе
	           , const int rand_max)           // максимальное случайное число
{
	*(pznachenue + 0) = rand_max * 100;        // значение последовательности при одном элементе

	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		*(pznachenue + n) = *(pznachenue + (n - 1)) - (rand() % rand_max); // следующий элемент меньше предыдущего на случайное число
	}// for
	return 0;                                  // возвращаем обещанное значение
}// lineubuvanie()


/*-------------------------------------------------*/
/* случайная  последовательность             */
/*-------------------------------------------*/
int slucaynaya(int* pznachenue                 // указатель на первый элемент динамического вектора
	         , int number                      // количество элементов в векторе
	         , const int rand_max)             // максимальное случайное число
{
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		*(pznachenue + n) = rand()% rand_max*100 + rand()%rand_max*10 + rand()%rand_max + n; // следующий вычисляется суммой случайных чисел
	}// for
	return 0;                                  // возвращаем обещанное значение
}// slucaynaya()


/*-------------------------------------------------*/
/* пилообразная  последовательность             */
/*----------------------------------------------*/
int piloobraznaya(int* pznachenue              // указатель на первый элемент динамического вектора
	            , int number                   // количество элементов в векторе
	            , const int rand_max)          // максимальное случайное число
{
	*(pznachenue + 0) = rand_max * 3;          // значение последовательности при одном элементе
	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++)     
	{
		if (n != interval)                     // если находимся в интервале роста
		{
			*(pznachenue + n) = *(pznachenue + (n - 1)) + (rand() % rand_max * 6); // следующий элемент больше предыдущего на случайное число
		}// if

		if ((n + 2) % interval == 0)           // если пред предпоследний элемент интервала(для плавного спуска)
		{
			*(pznachenue + n) = *(pznachenue + 0) + rand_max * 5;                  // плавно спустились

		}// if

		if ((n + 1) % interval == 0)          // если  предпоследний элемент интервала(для плавного спуска). Уменьшили на равномерное значение
		{
			*(pznachenue + n) = *(pznachenue + 0) + rand_max * 3;                  // плавно спустились
		}// if

		if (n % interval == 0)               // если  последний элемент интервала(для плавного спуска). Уменьшили на равномерное значение
		{
			*(pznachenue + n) = *(pznachenue + 0) + rand_max;                      // плавно спустились
		}// if
	}// for
	return 0;                                                                      // возвращаем обещанное значение
}// piloobraznaya()


/*-------------------------------------------------*/
/* ступенчатая  последовательность              */
/*----------------------------------------------*/
int stupenchataya(int* pznachenue           // указатель на первый элемент динамического вектора
	            , int number                // количество элементов в векторе
	            , const int rand_max)       // максимальное случайное число
{
	int stupenka = 10;                      // ступень подъёма функци
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		if ((n % interval != 0) || (n==0))  // если  находимся внитри интервала или в нуле
		{
			*(pznachenue + n) = rand() % rand_max  + stupenka;      // увеличиваем значение элемента массива на случайное число с учётом подъема ступеньки
		}
		else                                // дошли до конца интервала
		{
			*(pznachenue + n) = rand() % rand_max * 40 + stupenka;  // элемента массива значение резко выросло 
		}// if
		stupenka = *(pznachenue + n) +3;   // увеличили ступеньку, чтобы график шёл вверх
	}// for
	return 0;                               // возвращаем обещанное значение
}// stupenchataya()


/*-------------------------------------------------*/
/* квази-упорядоченная  последовательность      */
/*----------------------------------------------*/
int kvazi( int* pznachenue                  // указатель на первый элемент динамического вектора
	     , int number                       // количество элементов в векторе
	     , const int rand_max)              // максимальное случайное число
{
	int zamena = 0;                         // для индекса элемента, на который будем заменять
	int promeg = 0;                         // для хранения элемента массива
	*(pznachenue + 0) = (rand() % rand_max)*10+2;                             // значение последовательности при одном элементе
	// заполняем элементы массива, начиная со 2-го
	for (int n = 1; n < number; n++) 
	{
		*(pznachenue + n) = *(pznachenue + (n - 1)) + rand() % rand_max  + 3; // следующий элемент больше предыдущего на случайное число
	}// for
	// проходим заново элементы массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		if (n % 20 == 0)                   // берём каждый 20-й
		{
			zamena = rand() % number   ;   // вычисляем индекс элемента массива, на который будем заменять текущий элемент массива
			promeg = *(pznachenue + n);    // сохраняем элемент массива, на котором остановились
			*(pznachenue + n) = *(pznachenue + zamena);  // заменяем элемент, на новый, индекс которого вычислили
			*(pznachenue + zamena) = promeg;             //  поменяли местами элементы
		}// if
	}// for
	return 0;                              // возвращаем обещанное значение
}// kvazi()


/*-------------------------------------------------*/
/* синусоидальная  последовательность           */
/*----------------------------------------------*/
int sinus(int* pznachenue                                 // указатель на первый элемент динамического вектора
	    , int number                                      // количество элементов в векторе
	    , const int rand_max)                             // максимальное случайное число
{
	int step = 1;                                                                // шаг счёта углов
	int ugol = 0;                                                                // стартовое значение угла
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		ugol = (180 * step * n)/3.14;                                            // вычисляем новый угол в радианах
		*(pznachenue + n) = int(sin(ugol)*100);                                  // подсчёт
		if (n % 10 == 0)                                                         // отклонение максимального и минимального значения для каждого 10-го элемента
		{
			*(pznachenue + n) = *(pznachenue + n) + rand()% (rand_max * 3);      // добавляем к элементу с этим индексом случайное значение
		}// if
	}// for
	return 0;                                             // возвращаем обещанное значение
}// sinus()


/*-------------------------------------------------*/
/* выбор функции из массива                     */
/*----------------------------------------------*/
int(*MENU())(int*, int, const int) // в первых скобках имя функции со списком параметров. Далее спецификация параметров функции
{
	int choise;
	string name[8] = { "slucaynaya", "lineubuvanie", "linevozrastanie", "piloobraznaya", "stupenchataya","kvazi","sinus" "Exit." };       // массив названий алгоритмов поиска для печати названия выбранного алгоритма на экран// выбор пользователя
	int (*functions[])(int*, int, const int) = { slucaynaya, lineubuvanie, linevozrastanie, piloobraznaya, stupenchataya, kvazi, sinus }; // массив указателей на функции, соответствующий их типам и типам их параметров
	cout << "\nВыберете функцию: 1 - 8, где 8 - выход \n";
	cout << "Вы ввели: ";
	cin >> choise;                                                              // ввод выбора пользователя
	if ((choise > 0) && (choise < 8))                                           // если попали в диапазон номеров
	{
		cout << "\t\t\t\t\t\tФ У Н К Ц И Я   " << name[choise - 1] << endl << endl;           // выводим название алгоритма из массива
		return functions[choise - 1];                                           // вывели соответствующий указатель
	}
	else
	{
		return NULL;                                                            // нулевой указатель - сбой работы
	}// if
}// *MENU()


/*-------------------------------------------------*/
/* создание динамического массива               */
/*----------------------------------------------*/
void sozdanie(int** pznachenue                                                 // адрес указателя на динамический вектор, для изменения его содержимого
	        , int& number)                                                     // количество элементов в векторе
{
	cout << "Введите количество элементов последовательности: ";
	cin >> number;                                                             // ввод пользователем количества элементов массива
	cout << endl;                                                              // эхо-печать
	*pznachenue = new int[number];                                             // создаём соответствующий динамический массив
	return ;                                                                   // возвращаем обещанное значение
}// sozdanie()


/*-------------------------------------------------*/
/* удаление динамического массива               */
/*----------------------------------------------*/
void udalenie(int* pznachenue)                                                // указатель на первый элемент динамического вектора
{
	delete [] pznachenue;                                                     // удалили динамический вектор
	return;                                                                   // возвращаем обещанное значение
}// udalenie()


/*-------------------------------------------------*/
/* печать получившегося динамического массива   */
/*----------------------------------------------*/
void pechat_int_mass(int* pznachenue                                         // указатель на первый элемент динамического вектора
	               , int number                                              // количество элементов в векторе
	               , const int rand_max)                                     // максимальное случайное число
{
	ofstream fout;                                                           // объявление объекта для потокового вывода данных в файл
	fout.open(FNAME_1, ios::_Nocreate);                                      // связываем обЪект с файлом. Открываем для записи, если такой файл существует

	if (!fout.is_open())                                                     // файл не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить запись\n";
		fout.close();                                                       // закрыть файл для записи
		system("pause");
		return;                                                             // возвращаем значение, соответствующее типу
	}// if

	int(*choise)(int*, int, const int);                                     // указатель на функцию, выбранную пользователем
	while (1)                                                               // бесконечный цикл выбора до момента пока пользователь не выберет Exit.
	{  
		cout << "\t\t\t\t\t Р А Б О Т А   С   Ц Е Л Ы М И   Ч И С Л А М И\n\n";
		pechatusloviy();                                                    // вывод функции печати условий
		choise = MENU();                                                    // присваиваем указателю функцию из массива, выбранную пользователем
		if (choise == NULL)                                                 // если вышли за рамки диапазона допустимого
		{
			cout << " \t\t\t\tВ Ы Х О Д\n\n";
			cout << "Завершение программы для целых чисел\n";
			fout << "\nЗавершение программы для целых чисел\n";             // запись в файл
			system("pause"); 
			break;                                                          // закончили цикл
		}// if
		sozdanie(&pznachenue, number);                                      // создали динамический вектор с регулируемым числом элементов
		auto start = chrono::steady_clock::now();                           // начали отсчитывать время работы
		choise(pznachenue, number, rand_max);                               // вызвали функцию, выбранную из массива через указатель
		auto end = chrono::steady_clock::now();                             // закончили отсчитывать время работы
		cout << "\t\t\t\t Ц Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й: \n";
		fout << "\n\t\t\t\t Ц Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й: \n";
		setlocale(0, "C");                                                  // выводим массив в красивых скобках
		cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;        // вывод верхних квадратных скобок
		for (int j = 0; j < number; j++)                                    // идем по всем элементам массива, используя адресную арифметику
		{ 
			cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznachenue + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
			fout << "\n" << *(pznachenue + j);// << setw(6) << setfill(' ') << "n = " << j + 1;  // запись в файл
		}// for
		cout << '\n';
		cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217<<endl;  // вывод нижних квадратных скобок
		setlocale(LC_ALL, "Rus");                                           // подключаем русский язык 
		cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунды; \n\n";             // выводим на экран время работы
		fout << "\n" << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунды; \n\n";     // выводим в файл время работы
		system("pause");
		system("cls");                                                      // для каждой новой функции чистим экран
		udalenie(pznachenue);                                               // для каждой новой функции создаём динамический ветор заново
	}// while
	fout.close();                                                           // закрыть файл для записи
	return;                                                                 // возвращаем обещанное значение
}// pechat_int_mass()


//Для плавающей запятой:
/*-------------------------------------------------*/
/* монотонно-возрастающая последовательность */
/*-------------------------------------------*/
double linevozrastanie(double *pznacheniedoub                             // указатель на первый элемент динамического вектора
	                 , int number                                         // количество элементов в векторе
	                 , const int rand_max)                                // максимальное случайное число
{
	*(pznacheniedoub+0) = rand() % rand_max + 5.678;                      // значение последовательности при одном элементе
	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		*(pznacheniedoub + n) = *(pznacheniedoub+(n - 1)) + double(rand() % rand_max + 1.43);   // следующий элемент больше предыдущего на случайное число
	}// for
	return 0;                                                             // возвращаем обещанное значение
}// linevozrastanie()


/*-------------------------------------------------*/
/* монотонно-убывающая последовательность    */
/*-------------------------------------------*/
double lineubuvanie(double* pznacheniedoub                                 // указатель на первый элемент динамического вектора                  
	, int number                                                           // количество элементов в векторе
	, const int rand_max)                                                  // максимальное случайное число
{
	*(pznacheniedoub + 0) = rand_max * 100.54;                             // значение последовательности при одном элементе
	
	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		*(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) - double(rand() % rand_max + 0.9486);  // следующий элемент меньше предыдущего на случайное число
	}// for
	return 0;                                                              // возвращаем обещанное значение
}// lineubuvanie()


/*-------------------------------------------------*/
/* случайная  последовательность             */
/*-------------------------------------------*/
double slucaynaya(double* pznacheniedoub                                   // указатель на первый элемент динамического вектора
	            , int number                                               // количество элементов в векторе                  
	            , const int rand_max)                                      // максимальное случайное число
{             
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		*(pznacheniedoub + n) = double(rand() % rand_max * 100.2 + rand() % rand_max * 12.6567 + rand() % rand_max*1.3456) + n;   // следующий вычисляется суммой случайных чисел
	}// for
	return 0;                                                              // возвращаем обещанное значение
}// slucaynaya()


/*-------------------------------------------------*/
/* пилообразная  последовательность             */
/*----------------------------------------------*/
double piloobraznaya(double* pznacheniedoub                                // указатель на первый элемент динамического вектора
	, int number                                                           // количество элементов в векторе
	, const int rand_max)                                                  // максимальное случайное число
{ 
	*(pznacheniedoub + 0) = rand_max * 3.6754;                             // значение последовательности при одном элементе
	// заполняем оставшиеся элементы динамического массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		if (n != interval)                                                 // если находимся в интервале роста
		{
			*(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) + double(rand() % rand_max * 6.45);  // следующий элемент больше предыдущего на случайное число
		}// if

		if ((n + 2) % interval == 0)                                      // если пред предпоследний элемент интервала(для плавного спуска)
		{
			*(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max * 5.67);                 // плавно спустились

		}// if

		if ((n + 1) % interval == 0)                                      // если  предпоследний элемент интервала(для плавного спуска). Уменьшили на равномерное значение
		{
			*(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max * 3.32);                 // плавно спустились
		}// if

		if (n % interval == 0)                                            // если  последний элемент интервала(для плавного спуска). Уменьшили на равномерное значение           
		{
			*(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max);                        // плавно спустились
		}// if 
	}// for
	return 0;
}// piloobraznaya()


/*-------------------------------------------------*/
/* ступенчатая  последовательность              */
/*----------------------------------------------*/
double stupenchataya(double* pznacheniedoub                               // указатель на первый элемент динамического вектора
	               , int number                                           // количество элементов в векторе
	               , const int rand_max)                                  // максимальное случайное число
{
	double stupenka = 20.234;                                             // ступень подъёма функци
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		if ((n % interval != 0) || (n == 0))                              // если  находимся внитри интервала или в нуле          
		{
			*(pznacheniedoub + n) = rand() % rand_max + stupenka;         // увеличиваем значение элемента массива на случайное число с учётом подъема ступеньки     
		}
		else                                                              // дошли до конца интервала
		{
			*(pznacheniedoub + n) = rand() % rand_max * 40.345 + stupenka;   // элемента массива значение резко выросло 
		}// if
		stupenka = *(pznacheniedoub + n) + 3.4657;                           // увеличили ступеньку, чтобы график шёл вверх
	}// for
	return 0;                                                                // возвращаем обещанное значение
}// stupenchataya()


/*-------------------------------------------------*/
/* квази-упорядоченная  последовательность      */
/*----------------------------------------------*/
double kvazi(double* pznacheniedoub                                           // указатель на первый элемент динамического вектора
	       , int number                                                       // количество элементов в векторе
	       , const int rand_max)                                              // максимальное случайное число
{
	int zamena = 0;                                                           // для индекса элемента, на который будем заменять
	double promeg = 0;                                                        // для хранения элемента массива
	*(pznacheniedoub + 0) = (rand() % rand_max) * 10.34 + 2.132;              // значение последовательности при одном элементе
	// заполняем элементы массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		*(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) + rand() % rand_max + 3.345; // следующий элемент больше предыдущего на случайное число
	}// for
	// проходим заново элементы массива, начиная со 2-го
	for (int n = 1; n < number; n++)
	{
		if (n % 20 == 0)                                                      // берём каждый 20-й           
		{
			zamena = rand() % number;                                         // вычисляем индекс элемента массива, на который будем заменять текущий элемент массива     
			promeg = *(pznacheniedoub + n);                                   // сохраняем элемент массива, на котором остановились        
			*(pznacheniedoub + n) = *(pznacheniedoub + zamena);               // заменяем элемент, на новый, индекс которого вычислили
			*(pznacheniedoub + zamena) = promeg;                              // поменяли местами элементы
		}// if
	}// for
	return 0;                                                                 // возвращаем обещанное значение
}// kvazi()


/*-------------------------------------------------*/
/* синусоидальная  последовательность           */
/*----------------------------------------------*/
double sinus(double* pznacheniedoub                                          // указатель на первый элемент динамического вектора          
	       , int number                                                      // количество элементов в векторе
	       , const int rand_max)                                             // максимальное случайное число
{
	double step = 1;                                                         // шаг счёта углов                    
	double ugol = 0.1;                                                       // стартовое значение угла
	// заполняем оставшиеся элементы динамического массива, начиная со 1-го
	for (int n = 0; n < number; n++)
	{
		ugol = (180 * step * n) / 3.14;                                      // вычисляем новый угол в радианах
		*(pznacheniedoub + n) = double(sin(ugol) * 100);                     // подсчёт
		if (n % 10 == 0)                                                     // отклонение максимального и минимального значения
		{
			*(pznacheniedoub + n) = *(pznacheniedoub + n) + rand() % (rand_max * 3) + 0.345;  // добавляем к элементу с этим индексом случайное значение
		}// if
	}// for
	return 0;
}// sinus()


/*-------------------------------------------------*/
/* выбор функции из массива                     */
/*----------------------------------------------*/
double (*MENU2())(double*, int, const int)                                  // в первых скобках имя функции со списком параметров. Далее спецификация параметров функции    
{
	int choisedoub;                                                         // выбор пользователя
	string name[8] = { "slucaynaya", "lineubuvanie", "linevozrastanie", "piloobraznaya", "stupenchataya","kvazi","sinus" "Exit." };
	double (*functionsdoub[])(double*, int, const int) = { slucaynaya, lineubuvanie, linevozrastanie, piloobraznaya, stupenchataya, kvazi, sinus };  // массив указателей на функции, соответствующий их типам и типам их параметров
	cout << "\nВыберете функцию: 1 - 8, где 8 - выход \n";
	cout << "Вы ввели: ";
	cin >> choisedoub;                                                       // ввод выбора пользователя           
	if ((choisedoub > 0) && (choisedoub) < 8)                                // если попали в диапазон номеров
	{
		cout << "\t\t\t\t\t\tФ У Н К Ц И Я   " << name[choisedoub - 1] << endl << endl;           // выводим название алгоритма из массива
		return functionsdoub[choisedoub - 1];                                // вывели соответствующий указатель
	}
	else
	{
		return NULL;                                                         // возвращаем нулевой указатель
	}// if
}// MENU2()


/*-------------------------------------------------*/
/* создание динамического массива               */
/*----------------------------------------------*/
void sozdanie(double** pznacheniedoub                                        // адрес указателя на динамический вектор                      
	        , int& number)                                                   // количество элементов в векторе           
{
	cout << "Введите количество элементов последовательности: ";
	cin >> number;                                                           // ввод пользователем количества элементов массива                                   
	cout << endl;
	*pznacheniedoub = new double[number];                                    // создаём соответствующий динамический массив         
	return;                                                                  // возвращаем обещанное значение         
}// sozdanie()


/*-------------------------------------------------*/
/* удаление динамического массива               */
/*----------------------------------------------*/
void udalenie(double* pznacheniedoub)                                        // указатель на первый элемент динамического вектора                  
{
	delete[] pznacheniedoub;                                                 // удалили динамический вектор        
	return;                                                                  // возвращаем обещанное значение          
}// udalenie()


/*-------------------------------------------------*/
/* печать получившегося динамического массива   */
/*----------------------------------------------*/
void pechat_doub_mass(double pznacheniedoub[]                                // указатель на первый элемент динамического вектора               
	                , int number                                             // количество элементов в векторе
	                , const int rand_max)                                    // максимальное случайное число
{
	ofstream fout;                                                           // объявление объекта для потокового вывода данных в файл
	fout.open(FNAME_2, ios::_Nocreate);                                      // связываем обЪект с файлом. Открываем для чтения

	if (!fout.is_open())                                                     //файл не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить запись\n";
		fout.close();                                                        // закрыть файл для записи
		system("pause");
		return;                                                              // возвращаем значение, соответствующее типу
	}// if

	double(*choisedoub)(double*, int, const int);                            // указатель на функцию, выбранную пользователем          
	while (1)                                                                // бесконечный цикл выбора до момента пока пользователь не выберет Exit.        
	{
		cout << "\t\t\t\t Р А Б О Т А   С    Ч И С Л А М И   C   П Л А В А Ю Щ Е Й   З А П Я Т О Й \n\n";
		pechatusloviy();                                                     // вывод функции печати условий          
		choisedoub = MENU2();                                                // присваиваем указателю функцию из массива, выбранную пользователем
		if (choisedoub == NULL)                                              // если вышли за рамки диапазона допустимого
		{
			cout << " \t\t\t\tВ Ы Х О Д\n\n";
			cout << "Завершение программы для чисел с плавающей точкой\n";
			fout <<  "\nЗавершение программы для чисел с плавающей точкой\n";// запись в файл  
			break;                                                           // закончили цикл         
		}// if
		sozdanie(&pznacheniedoub, number);                                   // создали динамический вектор с регулируемым числом элементов         
		auto start = chrono::steady_clock::now();                            // засекли время начала работы функции
		choisedoub(pznacheniedoub, number, rand_max);                        // вызвали функцию, выбранную из массива через указатель
		auto end = chrono::steady_clock::now();                              // засекли время конца работы функции
		cout << "\t\t\t М А С С И В   З Н А Ч Е Н И Й   Ч И С Е Л   С   П Л А В А Ю Щ Е Й   Т О Ч К О Й \n";
		fout << "\n\t\t\t М А С С И В   З Н А Ч Е Н И Й   Ч И С Е Л   С   П Л А В А Ю Щ Е Й   Т О Ч К О Й \n";
		setlocale(0, "C");                                                   // выводим массив в красивых скобках         
		cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;   // вывод верхних квадратных скобок        
		for (int j = 0; j < number; j++)                                     // идем по всем элементам массива, используя адресную арифметику                 
		{
			cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznacheniedoub + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;;
			fout << "\n" << *(pznacheniedoub + j) /*<< setw(6) << setfill(' ') << "n = " << j + 1*/;  // запись в файл      
		}// for
		cout << '\n';
		cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;    // вывод нижних квадратных скобок
		setlocale(LC_ALL, "Rus");                                             // подключаем русский язык
		cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунды; \n\n";            // вывод на экран времени работы функции
		fout << "\n" << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунды; \n\n";    // вывод в файл времени работы функции
		system("pause");
		system("cls");                                                        // для каждой новой функции чистим экран          
		udalenie(pznacheniedoub);                                             // для каждой новой функции создаём динамический ветор заново        
	}// while
	fout.close();                                                             // закрыть файл для записи           
	return;                                                                   // возвращаем обещанное значение      
}// pechat_doub_mass()